#!/usr/bin/env python3
"""
Management command to load tenants from CSV file into the database.

This command reads the tenants.csv file generated by gen_dataset.py and creates
the corresponding Tenant records in the database.

Usage:
    python manage.py load_tenants --file generated_data/tenants.csv
    python manage.py load_tenants --file generated_data/tenants.csv --dry-run
"""

import csv
import hashlib
import uuid
from datetime import datetime
from pathlib import Path

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction

from apps.tenants.models import Tenant


class Command(BaseCommand):
    help = 'Load tenants from CSV file into the database'

    def add_arguments(self, parser):
        parser.add_argument(
            '--file',
            type=str,
            required=True,
            help='Path to the tenants CSV file'
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Show what would be created without actually creating tenants'
        )
        parser.add_argument(
            '--overwrite',
            action='store_true',
            help='Overwrite existing tenants with the same tenant_id'
        )

    def handle(self, *args, **options):
        file_path = Path(options['file'])
        dry_run = options['dry_run']
        overwrite = options['overwrite']

        if not file_path.exists():
            raise CommandError(f'File not found: {file_path}')

        self.stdout.write(f'Loading tenants from: {file_path}')

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                tenants_data = list(reader)

            self.stdout.write(f'Found {len(tenants_data)} tenants in CSV file')

            if dry_run:
                self.stdout.write(self.style.WARNING('DRY RUN MODE - No changes will be made'))
                self._show_tenants_preview(tenants_data)
                return

            created_count = 0
            updated_count = 0
            skipped_count = 0

            with transaction.atomic():
                for tenant_data in tenants_data:
                    result = self._create_or_update_tenant(tenant_data, overwrite)
                    if result == 'created':
                        created_count += 1
                    elif result == 'updated':
                        updated_count += 1
                    else:
                        skipped_count += 1

            self.stdout.write(
                self.style.SUCCESS(
                    f'Successfully processed tenants: '
                    f'{created_count} created, {updated_count} updated, {skipped_count} skipped'
                )
            )

            # Show API keys for reference
            self._show_api_keys(tenants_data)

        except Exception as e:
            raise CommandError(f'Error processing tenants: {e}')

    def _create_or_update_tenant(self, tenant_data, overwrite):
        """Create or update a tenant record."""
        tenant_id = uuid.UUID(tenant_data['tenant_id'])
        name = tenant_data['name']
        api_key_hash = tenant_data['api_key_hash']
        created_at = datetime.fromisoformat(tenant_data['created_at'])

        try:
            tenant, created = Tenant.objects.get_or_create(
                tenant_id=tenant_id,
                defaults={
                    'name': name,
                    'api_key_hash': api_key_hash,
                    'created_at': created_at
                }
            )

            if not created:
                if overwrite:
                    tenant.name = name
                    tenant.api_key_hash = api_key_hash
                    tenant.created_at = created_at
                    tenant.save()
                    return 'updated'
                else:
                    return 'skipped'

            return 'created'

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'Error processing tenant {tenant_id}: {e}')
            )
            return 'error'

    def _show_tenants_preview(self, tenants_data):
        """Show a preview of tenants that would be created."""
        self.stdout.write('\nTenants that would be created:')
        self.stdout.write('-' * 80)
        
        for i, tenant_data in enumerate(tenants_data[:5]):  # Show first 5
            tenant_id = tenant_data['tenant_id']
            name = tenant_data['name']
            api_key = f"api_key_{tenant_id}"
            
            self.stdout.write(f'{i+1}. {name}')
            self.stdout.write(f'   Tenant ID: {tenant_id}')
            self.stdout.write(f'   API Key: {api_key}')
            self.stdout.write('')

        if len(tenants_data) > 5:
            self.stdout.write(f'... and {len(tenants_data) - 5} more tenants')

    def _show_api_keys(self, tenants_data):
        """Show the API keys for all tenants."""
        self.stdout.write('\n' + '=' * 80)
        self.stdout.write(self.style.SUCCESS('TENANT API KEYS FOR INGESTION'))
        self.stdout.write('=' * 80)
        
        for tenant_data in tenants_data:
            tenant_id = tenant_data['tenant_id']
            name = tenant_data['name']
            api_key = f"api_key_{tenant_id}"
            
            self.stdout.write(f'Tenant: {name}')
            self.stdout.write(f'API Key: {api_key}')
            self.stdout.write('-' * 40)
        
        self.stdout.write('\nUse these API keys with the bulk ingestion endpoints.')
        self.stdout.write('Example:')
        self.stdout.write('  curl -X POST http://localhost:8000/api/v1/ingest/orders/ \\')
        self.stdout.write('    -H "X-API-Key: api_key_<tenant_id>" \\')
        self.stdout.write('    -H "Idempotency-Key: unique-key-123" \\')
        self.stdout.write('    -F "file=@generated_data/orders_<tenant_id>_chunk_0000.ndjson"')

